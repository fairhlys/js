<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    .nav {
        background-color: pink;
        color: skyblue;
        width: 100px;
        height: 100px;
        margin: 100px auto;
    }

    .nav1 {
        background-color: pink;
        width: 100px;
        height: 100px;
        margin: 100px auto;
        border: 1px solid red;
    }
</style>

<body>
    <!-- 
        变量声明有let const
        建议是const优先：
            const语义化更好
            有了变量先给const，后面发现要修改的话再改为let
            即使数组和对象可以添加和删除，依然可以用const声明，因为它们在栈中存放的是地址，就算添加元素也没有修改在栈中的地址
            const声明的值不能改变，而且const声明变量的时候需要里面进行初始化
        WEB API的基本认识：
            作用：使用js操作html和浏览器
            分类：DOM(文档对象模型)和BOM(浏览器对象模型)
            DOM：document objext model：是用来呈现以及和任意html或xml文档交互的api
                    用来开发网页内容特效和实现用户交互
        DOM树：
            将html文档以树状结构直观的表现出来，我们称之为文档树或者DOM树
            描述网页内容关系的名词
            文档树直观的体现了标签和标签之间的关系
        DOM对象：浏览器根据html标签生成的js对象
            所有的标签属性都可以在这个对象上面找到
            修改这个对象的属性会自动映射到标签身上
            在html里面的标签，通过文档方法获取过来就变成了对象，标签的属性变成了对象的属性
        DOM的核心思想：把网页内容当作对象来处理
            而在DOM中，最大的对象就是document对象
            它提供的方法和属性都是用来访问和操作网页内容的
            网页的所有内容都在document对象里面

            1.获取DOM对象：一般而言，值都需要加引号
                获取body标签：document.body;整个内容
                获取html标签：document.documentElement;整个页面
                根据css选择器获取DOM对象：
                  选中标签才能进行操作，利用js选择页面中的标签
                  1.选择匹配css选择器的第一个元素：
                        语法：document.querySelector('CSS选择器')
                    包含一个或多个css选择器字符串
                    返回值是一个dom对象，否则返回null
                    这里的css选择器参考css的选择器，写法没有一点区别
                  2.选择匹配的css选择器的所有元素：
                        语法：document.querySelectorAll('css选择器')
                    返回值是一个存放着dom对象的伪数组，存放的它们的地址，不能使用pop等方法
                    但是得到的是一个伪数组,哪怕利用querySelectorAll获取到的只有一个元素，一样也是个伪数组：
                        有长度和索引号
                        但是没有pop，push等数组方法
                    想要得到里面的每一个元素，则需要遍历的方式获取
            2.操作dom对象的内容：
                根据  对象.属性  和  对象.方法()  的形式操作dom对象，对应的操作html标签
                1.对象.innerText属性
                   获取对应标签的文字内容，相当于这个对象的innerText属性的值就是该标签的文字内容
                   自然也是和修改对象属性值一样的修改
                   显示的是纯文本，不解析标签
                2.对象.innerHTML属性
                    获取对应标签的文字内容，相当于这个对象的innerHTML属性的值就是该标签的文字内容
                    自然也是和修改对象属性值一样的修改
                    会解析标签，多标签建议使用模板字符
            3.操作dom对象属性
                1.操作元素常用属性
                        通过js设置和修改标签元素的属性
                        常见属性：href title src等等
                        语法：
                            对象.属性 = 值
                2.操作元素样式属性
                        通过js设置和修改标签元素的样式属性
                        1.通过style属性操作css
                            语法：
                                对象.style.样式属性 = '值';
                                 对于background-color的修改，不能直接写，否则-会被识别为减号，这时候采用小驼峰backgroundColor
                                 还有borderTop之类的
                                 生成的是行内样式表，权重很高
                        2.操作类名操作css
                            如果要修改的样式比较多，直接通过style属性修改比较繁琐，可以通过借助于css类名的形式
                            语法：其实就是把写好的类名赋值给dom对象的className属性
                                元素.className = 'active';
                            1.由于class是关键字，所以使用className去代替
                            2.className是使用新值换旧值，如果需要添加一个类，需要保留之前的类名,就行内式那样写，否则则是新类覆盖旧类
                        3.通过classlist操作css
                            为了解决className容易覆盖以前的类名，我们可以通过classList的方式追加和删除类名
                            语法：
                                1.添加类：
                                    元素.classList.add('类名')
                                2.删除类
                                    元素.classList.remove('类名')
                                3.有就删除，没有就加上
                                    元素.classList.toggle('类名')
                                4.根据表达式判断删除还是添加类，true则添加，false则不加
                                    元素.classList.toggle('类名'，表达式)
                                classlist和classname的类名都不用加. ，但是queryselector需要
                                5.判断是否含有类：
                                    元素.classList.contains('类名')
                3.操作表单元素属性
                        表单的很多情况也需要修改属性，比如点击眼睛，可以看到密码，本质上是把表单类型转为文本框
                        正常的有属性的取值的，跟其他的标签属性没有任何区别
                        表单属性中，有的 添加就有效果，移除就没有，这样的一律用布尔值表示，true则添加，比如disabled，checked，selected,这些只接受Boolean值
                        获取：DOM对象.属性名
                            获取表单的里面的值，input.value，不能用innerHTML，后者只能对普通元素只用
                        设置：DOM对象.属性名 = 新值
                4.自定义属性：
                        标准属性：标签天生自带的属性，可以直接用点语法操作
                        自定义属性：
                            h5推出的专门的data-自定义属性
                            在标签上一律以data-开头
                            在dom对象上一律以dataset对象方式获取，获取的是该对象的自定义属性集合
                            假如设置了data-id='1';那么单单获取该自定义属性就是对象名.dataset.id
                        利用自定义属性可以绑定两个元素
                5.定时器：
                        需求：网页的倒计时
                        1.间歇函数：
                            1.开启定时器：
                                setInterval(函数，间隔时间);
                                间隔时间是间隔多少时间执行一次函数，单位是ms毫秒,所以输入的时候就不加ms了
                                作用：每间隔一段时间调用这个函数
                                语法：
                                    1.setInterval(()=>{

                                    },interval);箭头函数
                                    2.setInterval(function(){
                                    
                                    },interval);匿名函数，这里可以单独写好function，然后再放在里面，但是放进去时函数名不能加()
                                    因为加了()后马上就调用函数，所以直接写上函数名就行
                                    定时器返回的是一个id数字，是第几个定时器就返回几
                            2.关闭定时器：
                                let 变量名 =setInterval(函数，间隔时间);返回的是第几个定时器
                                clearInterval(变量名)：关闭定时器,一般不会刚创建就停止，而是满足一定条件后再停止
                            3.再一次打开定时器：
                                变量名=setInterval(函数，调用时间);
                    定时器-延时函数：
                            js内置的一个用来让代码延时执行的函数：
                            setTimeout
                                语法：let timer = setTimeout(回调函数,等待的毫秒数)
                                setTimeout仅仅只执行一次，是bom的方法，可以省略window
                            延时器需要等待，所以后面的代码会先执行
                            清除延时函数：
                                clearTimeout(timer)



    -->
    <div class="box">data</div>
    <div class="box">abc</div>
    <p id="nav">nav</p>
    <ul>
        <li>test</li>
        <li>test1</li>
        <li>test2</li>
    </ul>
    <img src="./img/photomode_08072024_154629.png" alt="">
    <div class="nav">123</div>
    <input type="text" placeholder="电脑">
    <input type="checkbox" name="">
    <input type="checkbox" name="">
    <input type="checkbox" name="">
    <div class="diy" data-id="1" data-num="1"></div>
    <script>
        const i = document.querySelector('.box');
        console.log(i.innerText);
        i.innerText = '第一个操作';
        console.log(i.innerText);
        i.innerHTML = `<strong>第二个操作</strong> `
        console.log(i.innerHTML);
        console.log(i.innerText);
        const j = document.querySelector('#nav');
        console.log(j);
        const k = document.querySelector('ul li:nth-child(1)');
        k.style.color = 'red';
        console.log(k);
        const l = document.querySelectorAll('ul li');
        console.log(l);
        for (let k = 0; k < l.length; k++) {
            l[k].style.color = 'skyblue';
            console.log(l[k]);
        }
        const imgs = document.querySelector('img');
        imgs.src = './img/1.png';
        imgs.title = 'pic';
        const box1 = document.querySelector('.nav');
        box1.classList.add('nav1');
        box1.classList.remove('nav');
        box1.classList.toggle('nav');
        box1.classList.toggle('nav');
        const inp = document.querySelector('input');
        console.log(inp.placeholder);
        inp.type = 'password';
        console.log(inp.type);
        const check = document.querySelectorAll('input[type = "checkbox"]');
        check[1].checked = true;
        const diy = document.querySelector('.diy');
        console.log(diy.dataset.id);

    </script>
</body>

</html>