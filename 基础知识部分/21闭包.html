<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 
    闭包：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域。
        也就是内层函数+外层函数的变量
        作用：封闭数据，提供操作，外部也可以访问函数内部的变量
        闭包就是 “能记住外部变量的内部函数”。
        满足闭包的两个条件：
            存在嵌套函数（内部函数 + 外部函数）；
            内部函数访问 / 修改了外部函数的局部变量；
            外部函数返回了内部函数（让内部函数能在外部被调用）。
            闭包的核心价值：让函数 “记住” 它创建时的环境（比如这里的变量 i），即使外部函数已经执行完毕，环境中的变量也不会被销毁。


    -->
    <script>
        function count() {
            let i = 0;
            function fu() {
                i++;
                console.log(i);
            }
            //这里fu函数的闭包就是自己加上外部的i
            return fu;
        }
        const fun = count();
        //当fu给fun时，不仅仅是fu函数，还有外部的i，也就是fu函数的闭包给了fun，因此i的值一直存放着（i的作用域其实也在fu的外部，因此fu执行完后，i也不会被消灭，而是会记住自己的值）
        //当然和fun是全局函数有关，全局作用域只会在页面关闭的时候才销毁，因此i一直不会被回收
        //也可能达成内存泄漏，比如i就没有被回收


        // 当你调用 count() 时，它会做两件事：
        // 创建局部变量 i = 0；
        // 定义内部函数 fu()；
        // 返回 fu 函数的引用。
        // const fun = count() 本质是：把返回的 fu 函数 “改名” 成了 fun，现在 fun 就等同于原来的 fu 函数。
        // 关键：count() 执行完后，按常理局部变量 i 应该被销毁（函数执行完后其作用域会释放），但这里因为 fu 函数还在引用 i，所以 i 会被 “保留” 下来 —— 这就是闭包的核心特性。
    </script>
</body>

</html>